# Call Graph

import Term from '@src/components/Term';

Most developers know the call stack: the list of all executed functions that have not yet concluded, at a certain point in time of our program's execution. The call stack, while useful, only paints a very narrow picture of our program. It can also be seen as a single slice of the call graph during [depth-first traversal](https://en.wikipedia.org/wiki/Depth-first_search).


## Sync Call Graph

When investigating an application without any asynchronous events, the call graph is best viewed in `Sync` mode. 
Initially, only it's single root is shown: the entry point of the application; more precisely: the first piece of code that Dbux recorded.

Each node represents one execution of a file or function. We internally refer to these as <Term term="context">contexts</Term>. TODO(virtual contexts + async explanations)

TODO: Sync graph children exclude [asynchronous continuations](#asynchronous-continuation).

Non-empty nodes have two (of three) buttons to their left:

* TODO(icon) one to only expand immediate children of the node. These are functions that were called directly by this context.
* TODO(icon) one to expand the entire sub-tree.
* TODO(icon) one to collapse the node.


TODO(pics)

TODO(explain call graph behavior of (different types of) modules)


## Async Call Graph

TODO


### Asynchronous Continuation

TODO

## Toolbar

### Details

In `async` mode, disabling `Details` visually compacts the graph. This is used to better expose high-level patterns between <Term term="cgr">CGRs</Term>. One can probably best see the "big picture" by disabling `Details` and then zooming out.

`Details` currently does nothing in [sync](#sync-call-graph) mode.
