"use strict";(self.webpackChunkdbux_docs=self.webpackChunkdbux_docs||[]).push([[647],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),u=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=u(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=u(n),h=a,m=d["".concat(c,".").concat(h)]||d[h]||p[h]||i;return n?r.createElement(m,o(o({ref:t},s),{},{components:n})):r.createElement(m,o({ref:t},s))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var u=2;u<i;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3755:function(e,t,n){n.d(t,{Z:function(){return c}});var r=n(7462),a=n(3366),i=n(7294),o=["path","children","title"],l={"dbux-code":"Dbux VSCode Extension"};function c(e){var t=e.path,n=e.children,c=e.title,u=(0,a.Z)(e,o);if(!t)throw new Error('invalid <CodeLink /> missing "path". - props: '+JSON.stringify(e,null,2));var s=function(e){return l[e]||(e.startsWith("dbux-")&&!e.startsWith("dbux-code")?"@dbux/"+e.substring(5):e)}(t);n=n||s,c=c||n;var p="https://github.com/Domiii/dbux/"+t;return i.createElement("a",(0,r.Z)({title:c,href:p},u),n)}},1333:function(e,t,n){n.d(t,{Z:function(){return o}});var r=n(7294),a=n(8767),i={cgr:"cgr",trace:"trace"};function o(e){var t=e.term,n=e.children,o=void 0===n?t:n,l=function(e){var t=i[e];return t?(0,a.Z)()+"advanced/terminology#"+t:null}(t);return l?r.createElement("a",{href:l,title:'lookup term: "'+t+'"'},o,r.createElement("sup",null,"\u2754")):r.createElement(r.Fragment,null,"$",o,r.createElement("span",{className:"color-gray border-gray round",title:'(could not look up "'+o+'")'},r.createElement("sup",null,"\u2753")))}},8767:function(e,t,n){n.d(t,{Z:function(){return a}});var r=n(2263);function a(){return(0,r.Z)().siteConfig.baseUrl}},6582:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return u},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return m}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=n(3755),l=n(1333),c=["components"],u={},s="Call Graph",p={unversionedId:"using-dbux/call-graph",id:"using-dbux/call-graph",title:"Call Graph",description:"Most developers know the call stack: the list of all executed functions that have not yet concluded, at a certain point in time of our program's execution. The call stack, while useful, only paints a very narrow picture of our program. It can also be seen as a single slice of the call graph during depth-first traversal.",source:"@site/content/02-using-dbux/08-call-graph.mdx",sourceDirName:"02-using-dbux",slug:"/using-dbux/call-graph",permalink:"/dbux/using-dbux/call-graph",editUrl:"https://github.com/Domiii/dbux/blob/master/docs/content/content/02-using-dbux/08-call-graph.mdx",tags:[],version:"current",sidebarPosition:8,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Global View",permalink:"/dbux/using-dbux/global"},next:{title:"Trace Details",permalink:"/dbux/using-dbux/trace-details"}},d=[{value:"Sync Call Graph",id:"sync-call-graph",children:[],level:2},{value:"Async Call Graph",id:"async-call-graph",children:[{value:"Asynchronous Continuation",id:"asynchronous-continuation",children:[],level:3}],level:2},{value:"Toolbar",id:"toolbar",children:[{value:"Details",id:"details",children:[],level:3}],level:2},{value:"Implementation Details",id:"implementation-details",children:[],level:2}],h={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,c);return(0,i.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"call-graph"},"Call Graph"),(0,i.kt)("p",null,"Most developers know the call stack: the list of all executed functions that have not yet concluded, at a certain point in time of our program's execution. The call stack, while useful, only paints a very narrow picture of our program. It can also be seen as a single slice of the call graph during ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Depth-first_search"},"depth-first traversal"),"."),(0,i.kt)("h2",{id:"sync-call-graph"},"Sync Call Graph"),(0,i.kt)("p",null,"When investigating an application without any asynchronous events, the call graph is best viewed in ",(0,i.kt)("inlineCode",{parentName:"p"},"Sync")," mode.\nInitially, only it's single root is shown: the entry point of the application; more precisely: the first piece of code that Dbux recorded."),(0,i.kt)("p",null,"Each node represents one execution of a file or function. We internally refer to these as ",(0,i.kt)(l.Z,{term:"context",mdxType:"Term"},"contexts"),". TODO(virtual contexts + async explanations)"),(0,i.kt)("p",null,"TODO: Sync graph children exclude ",(0,i.kt)("a",{parentName:"p",href:"#asynchronous-continuation"},"asynchronous continuations"),"."),(0,i.kt)("p",null,"Non-empty nodes have two (of three) buttons to their left:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"TODO(icon) one to only expand immediate children of the node. These are functions that were called directly by this context."),(0,i.kt)("li",{parentName:"ul"},"TODO(icon) one to expand the entire sub-tree."),(0,i.kt)("li",{parentName:"ul"},"TODO(icon) one to collapse the node.")),(0,i.kt)("p",null,"TODO(pics)"),(0,i.kt)("p",null,"TODO(explain call graph behavior of (different types of) modules)"),(0,i.kt)("h2",{id:"async-call-graph"},"Async Call Graph"),(0,i.kt)("p",null,"TODO"),(0,i.kt)("h3",{id:"asynchronous-continuation"},"Asynchronous Continuation"),(0,i.kt)("p",null,"TODO"),(0,i.kt)("h2",{id:"toolbar"},"Toolbar"),(0,i.kt)("h3",{id:"details"},"Details"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"async")," mode, disabling ",(0,i.kt)("inlineCode",{parentName:"p"},"Details")," visually compacts the graph. This is used to better expose high-level patterns between ",(0,i.kt)(l.Z,{term:"cgr",mdxType:"Term"},"CGRs"),'. One can probably best see the "big picture" by disabling ',(0,i.kt)("inlineCode",{parentName:"p"},"Details")," and then zooming out."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Details")," currently does nothing in ",(0,i.kt)("a",{parentName:"p",href:"#sync-call-graph"},"sync")," mode."),(0,i.kt)("h2",{id:"implementation-details"},"Implementation Details"),(0,i.kt)("p",null,"A few more notes on the Call Graph GUI implementation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The Call Graph is implemented as a WebView."),(0,i.kt)("li",{parentName:"ul"},"Inside of ",(0,i.kt)("inlineCode",{parentName:"li"},"dbux-code"),", the graph is hosted in ",(0,i.kt)(o.Z,{path:"dbux-code/src/webViews/graphWebView.js",mdxType:"CodeLink"})),(0,i.kt)("li",{parentName:"ul"},"The Call Graph consists of three modules ",(0,i.kt)(o.Z,{path:"dbux-graph-common",mdxType:"CodeLink"}),", ",(0,i.kt)(o.Z,{path:"dbux-graph-client",mdxType:"CodeLink"})," and ",(0,i.kt)(o.Z,{path:"dbux-graph-host",mdxType:"CodeLink"}),"."),(0,i.kt)("li",{parentName:"ul"},"Client and host are running in separated runtimes, and they share the graph-common module for any code sharing between the two.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Theoretically, the client can also be rendered independent of VSCode, on a website, in an iframe etc."))),(0,i.kt)("li",{parentName:"ul"},"We developed an IPC-first component system to easily render things on the client, while allowing us to control it from the host."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"client")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"host")," communicate via a supplied ",(0,i.kt)("inlineCode",{parentName:"li"},"IpcAdapter")," which must provide two functions (whose implementation depends on the environment that they run in): ",(0,i.kt)("inlineCode",{parentName:"li"},"onMessage")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"postMessage"),".")))}m.isMDXComponent=!0}}]);