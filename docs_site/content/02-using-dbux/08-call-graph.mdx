# Call Graph

import Term from '@src/components/Term';

Most developers know the call stack: the list of all executed functions that have not yet concluded, at a certain point in time of our program's execution. The call stack, while useful, only paints a very narrow picture of our program. It can also be seen as a single slice of the call graph during [depth-first traversal](https://en.wikipedia.org/wiki/Depth-first_search).


## Sync Call Graph

When investigating an application without any asynchronous events, the call graph is best viewed in `Sync` mode. 
Initially, only it's single root is shown: the entry point of the application; more precisely: the first piece of code that Dbux recorded.

Each node represents one execution of a file or function. We internally refer to these as <Term term="context">contexts</Term>. TODO(virtual contexts + async explanations)

TODO: Sync graph children exclude [asynchronous continuations](#asynchronous-continuation).

Non-empty nodes have two (of three) buttons to their left:

* TODO(icon) one to only expand immediate children of the node. These are functions that were called directly by this context.
* TODO(icon) one to expand the entire sub-tree.
* TODO(icon) one to collapse the node.


TODO(pics)

TODO(explain call graph behavior of (different types of) modules)


## Async Call Graph

TODO


### Asynchronous Continuation

TODO

## Toolbar

### Details

In `async` mode, disabling `Details` visually compacts the graph. This is used to better expose high-level patterns between <Term term="cgr">CGRs</Term>. One can probably best see the "big picture" by disabling `Details` and then zooming out.

`Details` currently does nothing in [sync](#sync-call-graph) mode.



## Implementation Details

A few more notes on the Call Graph GUI implementation:

* The Call Graph is implemented as a WebView.
* Inside of `dbux-code`, the graph is hosted in <CodeLink path="dbux-code/src/webViews/graphWebView.js" />
* The Call Graph consists of three modules <CodeLink path="dbux-graph-common" />, <CodeLink path="dbux-graph-client" /> and <CodeLink path="dbux-graph-host" />.
* Client and host are running in separated runtimes, and they share the graph-common module for any code sharing between the two.
  * Theoretically, the client can also be rendered independent of VSCode, on a website, in an iframe etc.
* We developed an IPC-first component system to easily render things on the client, while allowing us to control it from the host.
* `client` and `host` communicate via a supplied `IpcAdapter` which must provide two functions (whose implementation depends on the environment that they run in): `onMessage` and `postMessage`.
