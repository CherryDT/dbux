# Performance

import CodeLink from '@src/components/CodeLink';

There are many performance considerations in tracing and recording *all* activity of a program.

Main considerations include:

* Instrumentation can be slow.
  * `@dbux/cli` uses [`@babel/register`](https://babeljs.io/docs/en/babel-register) with custom caching. That caching currently has limited configuration, but we hope for more in the future.
  * If you use a bundler, make sure to configure caching for it.
* When executing *a lot of stuff* (e.g. long loops or high FPS games etc), things will get slow
  * For example: Dbux probably won't really work at all if you run it on a 30+FPS game.
    * In that case, we might want to be very strategic in telling Dbux to only record: (i) initialization, (ii) a select few other functions and then (iii) several frames of the gameloop for our analysis.
  * Again, adaptive tracing is something we want to do in the future.
* When running a program with Dbux enabled, and also running it in debug mode in Node (i.e. `--inspect` or `--inspect-brk`), things slow down even worse. When things get too slow, you might want to consider using the `Run` button instead of the `Debug` button, and use the Dbux built-in features for debugging; unless there are some features in the traditional debugger that you just cannot live without in some specific circumstances.
* Recording of large arrays and objects is limited, according to some (currently hardcoded) `SerializationLimits`, to be found in <CodeLink path="dbux-runtime/src/data/valueCollection.js" />.


TODO: make this less messy; also link to "trace filters" and more relevant articles.


## Comment

Performance and scalability issues are often cited as the biggest problems for omniscient debuggers. However, as Henry Liebermann pointed out in reference to his omniscient debugger (called ZStep 95) in 1997[^1]: "Even in an extremely large program, where keeping a complete history is infeasible, judicious testing can often isolate a fragement of the code which is not too large to run ZStep on. Nevertheless, we admit that there may be bugs that appear only after long runs involving large amounts of code, and so our techniques may be inappropriate in these cases. However, we conjecture that the  vast majority of bugs are relatively shallow, and the productivity improvements from finding".

We believe, this applies to any omniscient debugger. While even large applications can be debugged with it, Dbux and its omniscient peers will falter when confronted with bugs in applications with high event frequency, such as games or complex algorithms running on a lot of data, if those bugs cannot be easily reproduced in a test case or short test run.


TODO: provide some numbers
